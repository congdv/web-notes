# Flask

Flask is a lightweight web framework for building web servers and serve HTML content to the web.

# Concepts

## Routes

In Flask, *routing* is the concept of mapping URLs, typed into the browser by the user, to Python functions you define in code for your application, to serve or handle the HTTP request generated by the URL access. That is, given a URL `foo.bar/baz`, we can register an *endpoint* with our our Flask application that will be executed upon access to that URL.

More precisely, there are two main ways of registering such an endpoint for a URL:

* The `flask.Flask.route()` decorator, which you will use most often to decorate your endpoints. As such, given your application instance called, say, `app`, you can use `@app.route()` to decorate your handler. The complete signature of the `route()` function is:
`route(rule, **options)`
Where `rule` is the string describing the URL to route to and options are a set of keyword arguments you may pass to configure the endpoint. For example, you can set the `methods` argument to an array of HTTP requests which you want to limit the endpoint to (as in, only those will be accepted for the endpoint): `methods=['GET', 'POST', ...]`. Note that `GET` implies support for `HEAD` and `OPTIONS`. Inside the endpoint, you can then query the method via `flask.request.method == 'GET'`, for example.
* The `flask.Flask.add_url_rule()` function, which acts exactly like the `route` decorator, but allows us to pass the URL rule (the URL we want to route) and the endpoint function directly, rather than through a decorator. Internally, `route()` uses `add_url_rule()`. Its signature is identical to that of `route()` in the `rule` and `**options` parameters, but takes two additional arguments after `rule`:
  - `endpoint`: The name of the endpoint (usually Flask assumes this is the name of the function)
  - `view_func`: The actual Python function to use.

One reason why the first argument to these methods is called a *rule*, suggesting some sort of background logic or validation mechanism, and not just plain *url* or *location*, is that it actually supports a micro-language for parameter-specification. That is, you may specify variable parts in a URL in angle brackets, optionally preceded by a converter such as `int` to transform the parameter, as it is passed as a (keyword) argument to the endpoint:

```py
@app.route('/users/<int:id>')
def endpoint(id):
  print(id)
```

Other supported converters are next to `int`:

* `string` (default)
* `float`
* `path`, which is like `string`, but accepts ("escapes") forward slashes.
* `any`, where you can specify a tuple of allowed values like so: `"<any('foo', 'bar', 'baz'):name>"`

and you can even [define your own](http://stackoverflow.com/questions/5870188/does-flask-support-regular-expressions-in-its-url-routing).

Note that you can route multiple URLs to the same endpoint, simply by chaining decorators:

```py
@app.route('/foo')
@app.route('/bar')
def endpoint():
  pass
```

Here, both `/foo` and `/bar` will route to the endpoint.

## Templates

The second essential element of Flask applications next to routes are
*templates*, which define the core layout and HTML structure of your website.
For this, Flask is paired with the *Jinja* template engine, which allows you to
use control flow structures and conditionals inside HTML and use placeholders
which you later on resolve to values on the "back-end", i.e. inside your
application Python code. You can think of the Jinja engine as a sophisticated
variant of `str.format`. An example HTML template using Jinja could look like
so:

```HTML
{% extends "layout.html" %}

{% block title %} Example {% endblock %}

{% block content %}

{% if session.name %}
  {{ placeholder }}
{% elif <condition> %}
  ...
{% else %}
  ...
{% endif %}

{% endblock %}
```

What we've done here is define an HTML file with *directives*, such as `if` or `block` and *placeholders*. For example, we can see that we can `extend`, i.e. inherit from, another HTML template. This is useful, since we may not want to define the `<html>`, `<body>` and other tags for each file and can rather put that boilerplate in one file, here called `layout.html`. Also note how we can access the `session` object from Jinja. In fact, we have access to the following Flask constructs in our Jinja templates:

* The `session` object.
* The `request` object.
* The `g` object.
* The `get_flashed_messages()` function.

To render a template with Jinja and resolve placeholders, you use the
`flask.render_template` method. Most importantly, if `{{ placeholder }}` defines
a placeholder for custom content, which we can supply it later like so:

```Python
@app.route('foo')
def foo():
  return flask.render_template('file.html', placeholder=5)
```

Here we supplied the integer `5` as the placeholder, which would be shown in the HTML. Naturally, in practice, you would actually replace the placeholder with some values you retrieved from, say, a database. We can pass as many placeholders as we want as keyword arguments. Also, instead of a single template file, we can pass a list of template files. The first *that exists* will be chosen.

There are some more concepts related to templates which we will explore in the following paragraphs.

### Syntax

#### For loops

Next to `if` the only other supported control flow directive if `for`, with which you can iterate over lists or objects (iterables) and even `range`s. Like `if`, you must terminate `for` block with `endfor`. Inside the block, you must refer to the iterated values through Jinja declarations (`{{ ... }}`). Note that you can perform any valid Python operation (expressions) on these objects -- there is no special language! An example is given below:

```HTML
{% for i in my_list %}
  <em>{{ i[0] }}</em>
{% endfor %}
```

Which we can resolve like so:

```py
@app.route('/')
def endpoint():
  return flask.render_template('file.html', my_list=[[1, 2], [3, 4]])
```

and will evaluate to:

```HTML
<em>1</em>
<em>2</em>
```

Note that there is one particular difference between Python and Jinja in terms of accessing dictionary properties. In Python, the only way to retrieve the value for a given key in a dictionary is the `dict['key']` syntax. This is also allowed in Jinja templates of course. However, additionally, in Jinja we are allowed to use the `dict.key` dot syntax like in JavaScript. As such, the following two statements are the same:

```HTML
{{ dict['key'] }}
{{ dict.key }}
```

#### Inheritance and Blocks

Jinja includes an inheritance mechanism that is incredibly useful to avoid code duplication, which is especially important in HTML, as they tend to have a great deal of boilerplate to deal with (`<head>` section, for example). You inherit from other templates using the `{% extends <file> %}` directive. But how do you move beyond the inheritance and extend the base template? For this, you use `block`s.

Basically, anytime you define a `{% block <name> %}` section and terminate it
with `{% endblock %}` inside your *base* (parent) template, this allows you to
override the contents of that block inside the child by referencing that block
with the exact same syntax. Moreover, we have access to whatever content we
place in the parent's block via the `super()` function.

For exmple, given this base template `base.html`:

```HTML
{% block foo %}
  Some content: {{ bar }}
{% endblock %}
```

We can extend it using Jinja's inheritance mechanism like so:

```HTML
{% extends "base.html" %}
{% block foo %}
  Parent's content: {{ super() }}
  More content: {{ baz }}
{% endblock %}
```

and render with:

```py
render_template('file.html', bar=123, baz='foo')
```

Note that next to the `extends` directive, there exists also the option to simply `{% include <file> %}` a file directly into the template:

```HTML
{% if ... %}
  {% include <file> %}
{% endif %}
```

### Macros

Jinja supports *macros* for "template functions". Essentially, they are blocks of Jinja template code and regular HTML that you can name and parameterize to reuse --- for convenience. For example, we may wish to write less code for `input` tags. Therefore, we write a macro (from [here](http://jinja.pocoo.org/docs/dev/templates/#macros)):

```HTML
{% macro input(name, value='', type='text', size=20) %}
    <input type="{{ type }}" name="{{ name }}" value="{{
        value|e }}" size="{{ size }}">
{% endmacro %}
```

As you can see, `macro`s are directives which you pass a function signature like in Python (with default arguments), which you can then reference via the placeholder syntax inside the macro block. Later, in our templates, we can use this macro in double braces (like placeholders):

```HTML
{{ input(foo) }}
```

However, note that if we want to place the macro into another file (like `macros.html` --- a good idea), we have to *import* the macro using the `import` syntax:

```HTML
{{ from '<file>' import <macro> with context }}
```

So, for example:

```HTML
{{ from 'macros.html' import input with context }}
```

The `with context` allows the macro to access its context, meaning the `request`, `session` and `g` objects and the `get_flashed_messages()` function. Otherwise, we'd have to pass these objects to the macro explicitly ([reference](http://flask.pocoo.org/docs/0.11/templating/)).

### Filters

Similar to expression filtering in Angular, we can also apply filters to our placeholder expressions in Jinja. For this, we simply pass our placeholder value to a filter function using the pipe symbol (`|`), which we can in turn chain into more filters via the pipe-separated syntax. For example, we can round a value to two digits past the decimal point:

```HTML
{{ number | round(precision=2) }}
```

Or join a list of strings:

```HTML
{{ list_of_numbers | join(', ') }}
```

Note how the filters have a Python-like syntax in terms of passing parameters in parentheses. However, if the filter takes no additional (positional, i.e. non-optional) parameters (next to the `value` being piped into the filter), we can omit the parentheses. For example, piping a sequence into `first` will return the first value:

```HTML
{{ [1, 2, 3] | first }} # => 1
```

#### Built-In Filters

With `round` and `join` we just saw two examples of *built-in filters*, i.e. filter functions that are directly built into Jinja. There exist many more, found [here](http://jinja.pocoo.org/docs/dev/templates/#list-of-builtin-filters). Among these are, for example:

* `capitalize(value)`: Capitalizes a value (first letter upper-case, all others lower-case).
* `default(value, default_value, boolean=False)`: If the argument (`value`) is `None`, returns the specified `default_value`. If `boolean` is `True`, treat values that evaluate to `False`, like empty sequences or strings, as undefined too.
* `format(*args, **kwargs)`: Formats a Python string using `str.format`, e.g. `{{ 'Hello, {0}!' | format('world') }}`

#### Custom Filters

Also, we can create our own filters very easily. We simply use the `template_filter` decorator on a function we wish to use as a filter. Such a function should take at least a `value` parameter (named any way you want, not necessarily `value`) and any other arguments your filter may require. For example:

```py
@app.template_filter()
def reverse(string):
  return string[::-1]
```

Optionally, the `template_filter` can take a name for the filter. By default the function's name is used (here "reverse"). Lastly, we just have to register it like so:

```py
app.jinja_env.filters['reverse'] = reverse
```

Then we can use it:

```HTML
{{ 'foo' | reverse }}
```

## Sessions

In Flask, a *session* is a cryptographically secure cookie that is unmodifiable by the user, unless the user has the *secret key* you usually set in your application at the start. The session object lives across several requests in your application, as opposed to the `flask.g` object, which survives only a single request-response cycle and is cleared after.

Sessions are what you usually use to store state in for your application, since the user cannot modify the cookie unless he/she is authorized (i.e. is you). For example, you would use a session to store the username of the current user and record whether or not the user is logged in or not.

To keep session cookies secret, a complex random secret key should be used. The recommended way is to generate a random string of bytes from a cryptographically secure source, such as `/dev/urandom`. For this, Python actually provides the `os.urandom(length)` function, which generates `length` many random bytes from an appropriate (safe) source from the OS. A good length would be around 24-32 bytes.

Resources:

* http://stackoverflow.com/questions/3948975/why-store-sessions-on-the-server-instead-of-inside-a-cookie
* http://stackoverflow.com/questions/32909851/flask-session-vs-g

## Request

Inside a Flask endpoint, you will often want to make use of the application-specific `flask.request` object, which stores information about the current request (the one being handled right now). You can use this request object to access URL parameters (for a REST-ful webservice), cookies, headers, uploaded files and also check the method used for the request. The latter is especially interesting to differentiate between POST and GET requests under the same endpoint. The `request` object is of `Flask.Request` type, which has the following interesting properties:

* `args`: The URL parameters passed after the question mark (`URL/?key=value`), in a dictionary.
* `headers`: The headers of the request, in a dictionary.
* `form`: Form data transmitted in the body of a POST request (with appropriate `x-www-form-urlencoded` content type), as a dictionary.
* `cookies`, as a dictionary.
* `method`: The method of the request, as a string.
* `files`: Files sent with the request. Note especially that these will not end up in the form data. They are stored as `Flask.FileStorage` files, behave like regular Python files, but have a `save(<file-path>)` method to save them to disk.

## Flashing

Message flashing is a simple communication method built into Flask to store
status, error, info, warning or any arbitrary messages of a category of your
choice. For example, when the user logs into her account, you can flash a
message using `flask.flash('Success!', category='status')`. The idea is that you
can actually retrieve and iterate over these flashed messages in your Jinja
templates (or in Python) via the `flask.get_flashed_messages()` method, which
returns a list of the message. Moreover, this method takes two additional,
optional parameters:

* `with_categories`: If `True`, returns the messages as (`category, message`) pairs.
* `category_filter`: An optional list of category strings by which to filter the messages. This is useful to render different kinds of messages in different HTML blocks or style them differently in your templates (for example, to display error messages with a red background and warning messages with an orange background).

For example:

```py
@app.route('/login', methods=['GET', 'POST'])
def login():
  error = None
  if flask.request.method == 'POST':
      if flask.request.form['username'] != app.config['USERNAME']:
          error = 'Invalid Username'
          flask.flash('There was an error', category='error')
      else:
          flask.session['logged_in'] = True
          flask.flash('You were logged in', category='status')
          return flask.redirect(flask.url_for('show_entries'))
  return flask.render_template('login.html', error=error)
```

And then:

```HTML
{% with messages = get_flashed_messages(with_categories=True, category_filter=['status', 'error']) %}
  {% if messages %}
  <ul>
    {% for category, message in messages %}
      <li class="{{ category }}">{{ message }}</li>
    {% endfor %}
  </ul>
  {% endif %}
{% endwith %}
```

The lifetime of flashed messages is only for a single request, which is the request directly following the one in which you flashed the message. The idea of this is that you flash the message in one request in response to some exceptional event in your application and then reflect that condition by displaying the message when rendering the page returned in the *next response*, i.e. following the next request.

## Cookies

Flask has native and intuitive support for cookies. To retrieve cookies from a request, simply access the `cookies` dictionary of the `flask.request` object:

```py
@app.route('/')
def endpoint():
  # assuming it will exist
  username = flask.request.cookies['username']
```

To set a cookie, you must manually create a response object via the `flask.make_response` method. This method simply takes the value we would usually return from our endpoint to create a response, but gives us a `Response` object. Most importantly, this `Response` object has a `set_cookie(key, value)` method, which we can use to set a cookie. You can also set an expiry date (timestamp) or timeout (how long it should be allowed to exist) and other options in the `set_cookie` method. However, `key` and `value` are required. Here is an example:

```py
@app.route('/')
def endpoint():
    response = flask.make_response(flask.render_template('file.html'))
    response.set_cookie('username', 'foo')
    return response
```

## Static Files

It is important to understand that Flask is, at the core, a web *framework*, not a web *server*. The difference is that a web server like nginx or Apache are C/C++ applications that handle the actual TCP connections and HTTP header parsing. Once it has parsed these headers, it would communicate with an intermediary web server like Gunicorn via the common gateway interface (CGI) or web server interface (WSGI) to move from the C/C++ domain to Python. Lastly, in Python, we have web frameworks like Flask, that handle dynamic response generation based on the request contents. As such, web servers can be seen as reverse proxies to the web framework. The reason why this discussion is relevant is that next to HTTP request handling, web servers like nginx also often handle static file serving. That is, it will serve static files like images or CSS stylesheets for you and only pass requests on to the web framework (Flask) for dynamic content generation. This is good, because web servers like nginx are usually quite fast. However, the bottom line is that Flask can also act as a web server and serve static content for you.

To serve static content in Flask, you can make use of the special `static` endpoint and pass the file path as a parameter to `flask.url_for`. Finally, you would simply redirect to that generated URL and Flask will do the rest for you:

```py
@app.route('/')
def index():
  return flask.redirect(flask.url_for('static', filename='foo/bar/baz'))
```

This will retrive the file from the `root/static/` path, i.e. here `root/static/foo/bar/baz` where `root` is your application's root folder.

Resources:
* http://flask.pocoo.org/docs/0.11/quickstart/#static-files
* https://www.quora.com/What-is-the-difference-between-a-web-server-and-a-web-framework

## Methods

### `url_for`

The `url_for` method will retrieve the url for a given *endpoint* for you. That is, if you have some endpoint function to which you're routing a URL like so:

```py
@app.route(<url>)
def endpoint(): pass
```

Then calling `flask.url_for(endpoint [, parameters])` will return the URL string for this endpoint, as specified in the `<url>` argument to `app.route()` in the decorator above the endpoint itself. You can use this as an argument to `flask.redirect`.

### `redirect`

The `flask.redirect` method will redirect the application to a new URL via an HTTP redirect. As such, the exact signature of this method is:

```py
flask.redirect(location, code=302, Response=None)
```

where `location` is a string describing the URL where to redirect to, `code` is the HTTP code to use for the generated redirect response and lastly an optional custom `Response` class to use when instantiating the response.

### `abort`

Use `abort` to simply interrupt the current request to raise an `HTTPException`, which will be handled by Flask accordingly. This means it will serve the correct content for the given error code, which is the `abort` functions only argument:

```py
@app.route('/foo')
def foo():
  abort(404) # fuck you
```

### `run`

The main entry point into your application, if you don't use the Flask `cli` utility, is `Flask.run()`. It optionally takes a `host` parameter, which is the IP address or hostname to listen on. It default to localhost, or `127.0.0.0`. Then, there is the `port` parameter, which defaults to 5000. Lastly, you can set `debug` to `True` for debug output.
